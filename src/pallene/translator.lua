-- Copyright (c) 2020, The Pallene Developers
-- Pallene is licensed under the MIT license.
-- Please refer to the LICENSE and AUTHORS files for details
-- SPDX-License-Identifier: MIT

-- !!! IMPORTANT - READ THIS !!!
--
-- If you change the output of this translator, please run the `benchmarks/generate_lua` script
-- to update the ".lua" files of our benchmarks.

----------

-- PALLENE TO LUA TRANSLATOR
-- =========================
-- One of the things Pallene promises is the Gradual Guarantee: the behavior of a Pallene program
-- should be similar to an equivalent Lua program that you would obtain by erasing all the type
-- annotations. To make it easier for us to test this property, this module implements such type
-- erasure algorithm. This alternate backend can be invoked using --emit-lua.
--
-- The generation of Lua is performed by a different backend (implemented here). It accepts input
-- string and the AST generated by the parser. The generator then walks over the AST replacing
-- type annotations with white space. Interestingly spaces, newlines, comments and pretty much
-- everything else other than type annotations are retained in the translated code. Thus, the
-- formatting in the original input is preserved, which means the error messages always point to
-- the same location in both Pallene and Lua code.

local util = require "pallene.util"

local translator = {}

local Translator = util.Class()

function Translator:init(input, preserve_columns)
    self.input = input -- string
    if preserve_columns then
        self.eraser = " " -- insert a space for each removed character
    else
        self.eraser = "" -- insert nothing when removing characters
    end
    self.last_index = 1 -- integer
    self.partials = {} -- list of strings
    return self
end

function Translator:add_previous(stop_index)
    assert(self.last_index <= stop_index + 1)
    local partial = self.input:sub(self.last_index, stop_index)
    --partial = partial:gsub('local ', '')
    table.insert(self.partials, partial)
    self.last_index = stop_index + 1
end

function Translator:erase_region(start_index, stop_index)
    assert(self.last_index <= start_index)
    assert(start_index <= stop_index + 1)
    self:add_previous(start_index - 1)

    local region = self.input:sub(start_index, stop_index)
    local partial = region:gsub("[^\n\r]", self.eraser)
    table.insert(self.partials, partial)

    self.last_index = stop_index + 1
end

-- This is a workaround to handle math.log built-in optimizations.
function Translator:prepend_compatibility_code()
    -- Note: We do not add a newline after this code injection in order to
    -- preserve line number parity with the original .pln file.
    -- It looks ugly, but correct line numbers are more useful.
    self.partials[1] = "math.ln = math.log; " .. self.partials[1]
end

function translator.translate(input, prog_ast, preserve_columns)
    local instance = Translator.new(input, preserve_columns)

    -- Erase all type regions, while preserving comments
    -- As a sanity check, assert that the comment regions are either inside or outside the type
    -- regions, not crossing the boundaries.
    local j = 1
    local comments = prog_ast.comment_regions
    for _, region in ipairs(prog_ast.type_regions) do
        local start_index = region[1]
        local end_index   = region[2]

        -- Skip over the comments before the current region.
        while j <= #comments and comments[j][2] < start_index do
            j = j + 1
        end

        -- Preserve the comments inside the current region.
        while j <= #comments and comments[j][2] <= end_index do
            assert(start_index <= comments[j][1])
            instance:erase_region(start_index, comments[j][1] - 1)
            start_index = comments[j][2] + 1
            j = j + 1
        end

        -- Ensure that the next comment is outside the current region.
        if j <= #comments then
            assert(end_index < comments[j][1])
        end

        instance:erase_region(start_index, end_index)
    end

    -- Whatever characters that were not included in the partials should be added.
    instance:add_previous(#input)

    -- This prepends any compatibility shims we need.
    instance:prepend_compatibility_code()

    return table.concat(instance.partials)
end

return translator
